--- ./Common/chip/inc/base_types.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Common/chip/inc/base_types.h	2019-04-17 14:51:12.422116638 +0100
@@ -46,15 +46,23 @@
 #endif  
 
 /** Returns the minimum value out of two values */
+#ifndef MIN
 #define MIN( X, Y )  ((X) < (Y) ? (X) : (Y))
+#endif
 
 /** Returns the maximum value out of two values */
+#ifndef MAX
 #define MAX( X, Y )  ((X) > (Y) ? (X) : (Y))
+#endif
 
 /** Returns the dimension of an array */
-#define  DIM( X )  (sizeof(X) / sizeof(X[0]))
+#ifndef DIM
+#define DIM( X )  (sizeof(X) / sizeof(X[0]))
+#endif
 
-#define  BIT(x)    ((uint32_t)1 << (x))
+#ifndef BIT
+#define BIT(x)    ((uint32_t)1 << (x))
+#endif
 
 typedef enum en{
 	Enable = 1,
--- ./Common/chip/inc/RS1xxxx.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Common/chip/inc/RS1xxxx.h	2019-04-24 19:32:12.067422021 +0100
@@ -151,7 +151,7 @@
 /* ----------------Configuration of the Cortex-M4 Processor and Core Peripherals---------------- */
 #define __CM4_REV                 0x0100            /*!< Cortex-M4 Core Revision                                               */
 #define __MPU_PRESENT                  1            /*!< MPU present or not                                                    */
-#define __NVIC_PRIO_BITS               4            /*!< Number of Bits used for Priority Levels                               */
+#define __NVIC_PRIO_BITS               6            /*!< Number of Bits used for Priority Levels                               */
 #define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
 #define __FPU_PRESENT                  1            /*!< FPU present or not                                                    */
 /** @} */ /* End of group Configuration_of_CMSIS */
--- ./Common/chip/src/system_RS1xxxx.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Common/chip/src/system_RS1xxxx.c	2019-04-18 16:17:48.571318396 +0100
@@ -45,7 +45,26 @@
  *----------------------------------------------------------------------------*/
 uint32_t SystemCoreClock = __SYSTEM_CLOCK;/*!< System Clock Frequency (Core Clock)*/
 
-SYSTEM_CLOCK_SOURCE_FREQUENCIES_T system_clocks; /*!< System Clock sources Frequencies */
+/*!< System Clock sources Frequencies */
+SYSTEM_CLOCK_SOURCE_FREQUENCIES_T system_clocks = {
+  .m4ss_ref_clk     = DEFAULT_32MHZ_RC_CLOCK,
+  .ulpss_ref_clk    = DEFAULT_32MHZ_RC_CLOCK,
+  .soc_pll_clock    = DEFAULT_SOC_PLL_CLOCK,
+  .modem_pll_clock  = DEFAULT_MODEM_PLL_CLOCK,
+  .modem_pll_clock2 = DEFAULT_MODEM_PLL_CLOCK,
+  .intf_pll_clock   = DEFAULT_INTF_PLL_CLOCK,
+  .soc_clock        = DEFAULT_32MHZ_RC_CLOCK,
+  .rc_32khz_clock   = DEFAULT_32KHZ_RC_CLOCK,
+  .rc_32mhz_clock   = DEFAULT_32MHZ_RC_CLOCK,
+  .ro_20mhz_clock   = DEFAULT_20MHZ_RO_CLOCK,
+  .ro_32khz_clock   = DEFAULT_32KHZ_RO_CLOCK,
+  .xtal_32khz_clock = DEFAULT_32KHZ_XTAL_CLOCK,
+  .doubler_clock    = DEFAULT_DOUBLER_CLOCK,
+  .rf_ref_clock     = DEFAULT_RF_REF_CLOCK,
+  .mems_ref_clock   = DEFAULT_MEMS_REF_CLOCK,
+  .byp_rc_ref_clock = DEFAULT_32MHZ_RC_CLOCK,
+  .i2s_pll_clock    = DEFAULT_I2S_PLL_CLOCK,
+};
 
 uint32_t npssIntrState =0;
 uint32_t __sp;
@@ -233,7 +252,7 @@
  *         retrieved from cpu registers.
  * @return none
  */
-void SystemCoreClockUpdate (void)            /* Get Core Clock Frequency      */
+void xxx_SystemCoreClockUpdate (void)            /* Get Core Clock Frequency      */
 {
   /*Updated the default SOC clock frequency*/
 	SystemCoreClock = DEFAULT_32MHZ_RC_CLOCK;
@@ -339,25 +358,6 @@
 	/* Configuring RC-32MHz Clock for HF-FSM */
 	RSI_PS_FsmHfClkSel(FSM_32MHZ_RC);
   
-  /*Update the system clock sources with source generating frequency*/  
-	system_clocks.m4ss_ref_clk 			= DEFAULT_32MHZ_RC_CLOCK;
-  system_clocks.ulpss_ref_clk			= DEFAULT_32MHZ_RC_CLOCK;
-	system_clocks.soc_pll_clock 		= DEFAULT_SOC_PLL_CLOCK;
-	system_clocks.modem_pll_clock 	= DEFAULT_MODEM_PLL_CLOCK;
-	system_clocks.modem_pll_clock2  = DEFAULT_MODEM_PLL_CLOCK;
-	system_clocks.intf_pll_clock 	  = DEFAULT_INTF_PLL_CLOCK;
-	system_clocks.soc_clock 				= DEFAULT_32MHZ_RC_CLOCK;
-	system_clocks.rc_32khz_clock 	  = DEFAULT_32KHZ_RC_CLOCK;
-	system_clocks.rc_32mhz_clock 	  = DEFAULT_32MHZ_RC_CLOCK;
-	system_clocks.ro_20mhz_clock 	  = DEFAULT_20MHZ_RO_CLOCK;
-	system_clocks.ro_32khz_clock 	  = DEFAULT_32KHZ_RO_CLOCK;
-	system_clocks.xtal_32khz_clock  = DEFAULT_32KHZ_XTAL_CLOCK;
-	system_clocks.doubler_clock 		= DEFAULT_DOUBLER_CLOCK;
-  system_clocks.rf_ref_clock  		= DEFAULT_RF_REF_CLOCK;
-  system_clocks.mems_ref_clock  	= DEFAULT_MEMS_REF_CLOCK;
-  system_clocks.byp_rc_ref_clock  = DEFAULT_32MHZ_RC_CLOCK;
-  system_clocks.i2s_pll_clock     = DEFAULT_I2S_PLL_CLOCK;
-  
 	/* Change the power state from PS4 to PS3 */		
 	RSI_PS_PowerStateChangePs4toPs3();
 	/* Configure DCDC to give lower output voltage.*/
@@ -383,7 +383,7 @@
 error_t RSI_PS_EnterDeepSleep(SLEEP_TYPE_T sleepType , uint8_t lf_clk_mode)
 {
 	volatile int var = 0, enable_sdcss_based_wakeup = 0, enable_m4ulp_retention = 0;
-	uint32_t ipmuDummyRead =0, m4ulp_ram_core_status = 0, m4ulp_ram_peri_status = 0, disable_pads_ctrl = 0 , ulp_proc_clk;
+	uint32_t ipmuDummyRead =0, m4ulp_ram_core_status = 0, m4ulp_ram_peri_status = 0, disable_pads_ctrl = 0 , ulp_proc_clk = 0;
 	volatile uint8_t in_ps2_state=0;
 
 	/*Save the NVIC registers */
@@ -604,7 +604,7 @@
  */
 void SystemInit (void)
 {
-	volatile uint32_t ipmuDummyRead=0, bypass_curr_ctrl_reg=0;
+	volatile uint32_t ipmuDummyRead=0;
 	volatile uint32_t spareReg2=0;
 
 	/*IPMU dummy read to make IPMU block out of RESET*/
--- ./Peripheral_Library/driver/inc/rsi_adc.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/inc/rsi_adc.h	2019-04-17 14:51:12.426116851 +0100
@@ -131,18 +131,18 @@
 \brief ADC channel Configuration structure
 */
 
-volatile typedef struct 
+typedef struct 
 {
-	 uint32_t ping_addr[16];
-	 uint32_t pong_addr[16];
-	 uint16_t ping_length[16];
-	 uint16_t pong_length[16];
-	 uint32_t ping_mem1[16];
-	 uint32_t ping_mem2[16];
-	 uint32_t ping_mem3[16];
-	 uint32_t pong_mem1[16];
-	 uint32_t pong_mem2[16];
-	 uint32_t pong_mem3[16];	 
+	 __IOM uint32_t ping_addr[16];
+	 __IOM uint32_t pong_addr[16];
+	 __IOM uint16_t ping_length[16];
+	 __IOM uint16_t pong_length[16];
+	 __IOM uint32_t ping_mem1[16];
+	 __IOM uint32_t ping_mem2[16];
+	 __IOM uint32_t ping_mem3[16];
+	 __IOM uint32_t pong_mem1[16];
+	 __IOM uint32_t pong_mem2[16];
+	 __IOM uint32_t pong_mem3[16];	 
 }adc_config_t;
  
 typedef struct
--- ./Peripheral_Library/driver/inc/rsi_ct.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/inc/rsi_ct.h	2019-04-17 14:51:12.426116851 +0100
@@ -912,6 +912,8 @@
 STATIC INLINE void RSI_CT_EdgeLevelEventControl(RSI_CT_T *pCT,uint32_t value)
 {
 	 //pCT ->RE_FE_RFE_LEV0_LEV1_EVENT_ENABLE_REG = value;	
+   (void) pCT;
+   (void) value;
 }
 
 /**
--- ./Peripheral_Library/driver/inc/rsi_cts.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/inc/rsi_cts.h	2019-04-17 14:51:12.426116851 +0100
@@ -55,7 +55,7 @@
  */
 STATIC INLINE void RSI_CTS_BypassPRS(CTS_Type *cts,boolean_t enable)
 {
-  CTS->CTS_CONFIG_REG_1_1_b.BYPASS=enable;
+  cts->CTS_CONFIG_REG_1_1_b.BYPASS=enable;
 }
 
 
--- ./Peripheral_Library/driver/inc/rsi_ethernet.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/inc/rsi_ethernet.h	2019-04-17 14:51:12.426116851 +0100
@@ -41,7 +41,7 @@
 /*******************************************************************************/
 /************************** Call Back Macros**************************************/
 /*******************************************************************************/
-#define RSI_NULL       0
+#define RSI_NULL       NULL
 
 #define GMAC_INTERRUPT 0x0000 /*!< GMAC interrupt*/
 #define DMA_INTERRUPT  0x0001 /*!< DMA interrupt*/
--- ./Peripheral_Library/driver/inc/rsi_sdioh.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/inc/rsi_sdioh.h	2019-04-17 14:51:12.426116851 +0100
@@ -542,7 +542,10 @@
 {
 	SDIOH_CARD_TYPE_T       cardType;          
 	uint32_t                maxSectorNum;       
-	SDIOH_CMD_OCR_T         ocr;                   
+	union {
+		SDIOH_CMD_OCR_T         ocr;                   
+		uint32_t ocrv;
+	};
 	uint8_t                 cid[16];                   
 	uint8_t                 csd[16];               
 	uint16_t                rca;                      
--- ./Peripheral_Library/driver/inc/rsi_sio.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/inc/rsi_sio.h	2019-04-17 14:51:12.426116851 +0100
@@ -284,7 +284,6 @@
  *  @{
  *
  */
-static void RSI_SIO_ClockEnable(void) ;
 void RSI_SIO_I2cGenerateStop(volatile SIO_Type *pstcSio);
 error_t RSI_SIO_Init(volatile SIO_Type *pstcSio);
 error_t RSI_SIO_InitSpi(volatile SIO_Type *pstcSio , stc_sio_spi_cfg_t  *pstcSpiConfig);
--- ./Peripheral_Library/driver/src/rsi_adc.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/src/rsi_adc.c	2019-04-17 14:51:12.430117065 +0100
@@ -56,9 +56,7 @@
 {
 	if(( channel > MAX_CHNL_NO)|| 
 		 ( ping_length > PING_LEN_MAX ) ||
-	   ( pong_length > PONG_LEN_MAX ) ||
-		 ( ping_addr > PING_ADDR_MAX  ) ||
-	   ( pong_addr > PONG_ADDR_MAX) )
+	   ( pong_length > PONG_LEN_MAX ) )
 	{
 	  return INVALID_PARAMETERS;
 	}		
@@ -143,12 +141,13 @@
 void RSI_ADC_Calibration(void)
 {
 	volatile uint32_t auxadcCalibValueLoad=0 , auxadcCalibValue=0;
-  volatile uint32_t calib_done=0,cal,impuDummyRead=0;
+  volatile uint32_t calib_done=0, impuDummyRead;
 
 	AUX_ADC_DAC_COMP->AUXADC_CTRL_1_b.ADC_ENABLE |= 1U;
 	AUX_ADC_DAC_COMP->AUXADC_CONFIG_2 |= BIT(10);
 
 	impuDummyRead = ULP_SPI_MEM_MAP(0);
+  (void) impuDummyRead;
 	if(calib_done==0)
 	{	
 	  ULP_SPI_MEM_MAP(AUXADCREG0) |= BIT(13) | BIT(12) | BIT(11) | BIT(8) | BIT(7) | BIT(6) ;
@@ -157,12 +156,12 @@
     while(!(ULP_SPI_MEM_MAP(SPAREREG2) & BIT(0)));
     /*wait for 0*/
     while((ULP_SPI_MEM_MAP(SPAREREG2) & BIT(0)));	
-	  /*150 clocks of 1 Mhz wait*/
-	  auxadcCalibValue = ULP_SPI_MEM_MAP(AUXADCREG2);
-	  auxadcCalibValueLoad |= BIT(0) | BIT(7);
-	  auxadcCalibValueLoad |= (auxadcCalibValue & 0x1F) <<2;
-	  auxadcCalibValueLoad |= (((auxadcCalibValue >> POS6) & 0x1F) << POS8);
-	  auxadcCalibValueLoad |= (((auxadcCalibValue >> POS11) & 0x1F) << POS13);
+    /*150 clocks of 1 Mhz wait*/
+    auxadcCalibValue = ULP_SPI_MEM_MAP(AUXADCREG2);
+    auxadcCalibValueLoad |= BIT(0) | BIT(7);
+    auxadcCalibValueLoad |= (auxadcCalibValue & 0x1F) <<2;
+    auxadcCalibValueLoad |= (((auxadcCalibValue >> POS6) & 0x1F) << POS8);
+    auxadcCalibValueLoad |= (((auxadcCalibValue >> POS11) & 0x1F) << POS13);
     calib_done = 1;
 	}
   else
@@ -546,6 +545,7 @@
 			 } 	 
 	  }	
 	}	
+  (void) pstcADC;
 	return RSI_OK;
 }
 
@@ -812,7 +812,7 @@
 		(AUX_ADC_DAC_COMP->INTERNAL_DMA_CH_ENABLE_b.INTERNAL_DMA_ENABLE ))
 	{
 		intr_status = RSI_ADC_ChnlIntrStatus(AUX_ADC_DAC_COMP);
-		if(intr_status!=NULL)
+		if(intr_status!=0)
 		{	
 		  if(intr_status & BIT(0))
 		  {	
@@ -904,6 +904,7 @@
 	  AUX_ADC_DAC_COMP->AUXADC_CTRL_1_b.ADC_FIFO_FLUSH = 1;
 		pADCCallBack ->adccallbacFunc(intr_status , FIFO_MODE_EVENT);
 	}	
+  (void) pstcADC;
 	return RSI_OK;
 }	
 
@@ -1016,7 +1017,7 @@
 float RSI_ADC_VrefCal(void)
 {
 	  volatile	uint32_t ldo_drv =0;
-    volatile float vref_v,adc_offset=0;	
+    volatile float vref_v;	
 		ldo_drv = AUX_ADC_DAC_COMP->AUX_LDO_b.LDO_CTRL;
 		if(AUX_ADC_DAC_COMP->AUX_LDO_b.BYPASS_LDO==1)
 		{
--- ./Peripheral_Library/driver/src/rsi_cts.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/src/rsi_cts.c	2019-04-17 14:51:12.430117065 +0100
@@ -201,6 +201,6 @@
  */
 void RSI_CTS_IntrClear(CTS_Type *cts)
 { 
-	CTS->CTS_CONFIG_REG_1_1_b.WAKE_UP_ACK =1;
-	CTS->CTS_CONFIG_REG_1_1_b.WAKE_UP_ACK =0;
+	cts->CTS_CONFIG_REG_1_1_b.WAKE_UP_ACK =1;
+	cts->CTS_CONFIG_REG_1_1_b.WAKE_UP_ACK =0;
 }
--- ./Peripheral_Library/driver/src/rsi_ethernet.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/src/rsi_ethernet.c	2019-04-17 14:51:12.430117065 +0100
@@ -752,6 +752,7 @@
 	 pDesc->RXDESC2 = (uint32_t)rcvcfg->dst;
 	
    pDesc->RXDESC1 = 	0x7FF | ((uint32_t) (0x7FF) << 11) | BIT(24);
+  (void) pETHHandle;
   return RSI_OK;
 }
 
@@ -849,6 +850,7 @@
 	
 	pDesc->TXDESC2 = (uint32_t)xfercfg->src;
 
+  (void) pETHHandle;
 
   return RSI_OK;
 
--- ./Peripheral_Library/driver/src/rsi_gpdma.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/src/rsi_gpdma.c	2019-04-17 14:51:12.430117065 +0100
@@ -241,8 +241,8 @@
 {
 	GPDMA_DATACONTEXT_T *pDrv = (GPDMA_DATACONTEXT_T *) pHandle;
 	pDrv->baseG->GLOBAL.DMA_CHNL_SQUASH_REG = SET_BIT(dmaCh);
-  /* Waiting till squash bit becomes '0' */
-  while(pDrv->baseG->GLOBAL.DMA_CHNL_SQUASH_REG &SET_BIT(dmaCh));
+	/* Waiting till squash bit becomes '0' */
+	while(pDrv->baseG->GLOBAL.DMA_CHNL_SQUASH_REG &SET_BIT(dmaCh));
 	return RSI_OK;
 }
 
@@ -553,7 +553,7 @@
 	{
 		pDesc->pNextLink = NULL;
 	}
-
+	(void) pHandle;
 	return RSI_OK;
 }  
 
--- ./Peripheral_Library/driver/src/rsi_qei.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/src/rsi_qei.c	2019-04-17 14:51:12.430117065 +0100
@@ -34,6 +34,7 @@
 {
 	/* QEI clock enable routine here */
 	clk_peripheral_clk_enable2(M4CLK,QE_PCLK_ENABLE);
+	(void) pstcQei;
 	return ;
 }
 
@@ -47,6 +48,7 @@
 {
 	/* clock disable to QEI module */
 	clk_peripheral_clk_disable2(M4CLK,QE_PCLK_ENABLE);
+	(void) pstcQei;
 	return ;
 }
 
--- ./Peripheral_Library/driver/src/rsi_qspi.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/src/rsi_qspi.c	2019-04-17 14:51:12.430117065 +0100
@@ -177,6 +177,8 @@
 	qspi_switch_qspi2(qspi_reg, qspi_operational_mode, cs_no);
 	DEASSERT_CSN;
 
+	(void) wr_reg_delay_ms;
+
 	return flash_status;
 
 
@@ -196,6 +198,7 @@
 		qspi_write_to_flash(qspi_reg, QSPI_8BIT_LEN, WREN2, cs_no);
 	}
 	DEASSERT_CSN;
+	(void) flash_type;
 }
 
 void qspi_status_reg_write (
@@ -579,7 +582,8 @@
 	qspi_switch_qspi2(qspi_reg, SINGLE_MODE, cs_no);
 }
 #endif  
-
+	(void) ddr_mode_en;
+	(void) reset_bus_mode;
 }
 
 void qspi_status_control_reg_write(spi_config_t * spi_config, qspi_reg_t *qspi_reg, uint16_t write_command, uint32_t addr, uint16_t write_value, uint32_t cs_no, uint32_t wr_reg_delay_ms)
@@ -742,8 +746,8 @@
 	
 	do {
       while(qspi_reg->QSPI_STATUS_REG & QSPI_FIFO_EMPTY_RFIFO_S);          
-    
-	 if(spi_config->spi_config_3.ddr_mode_en){
+
+      if(spi_config->spi_config_3.ddr_mode_en){
        junk = (uint16_t)qspi_reg->QSPI_MANUAL_RD_WR_DATA_REG;
      } else {
        junk = (uint8_t)qspi_reg->QSPI_MANUAL_RD_WR_DATA_REG;
@@ -762,6 +766,8 @@
 	}
 
 	//XXX CSN must not be deassert here...
+
+	(void) junk;
 }
 
 void  RSI_QSPI_GPDMA_Init(uint32_t hsize, uint32_t ch_no, uint32_t mode) 
@@ -1969,6 +1975,7 @@
 			}
 		}
 	}
+	(void) write_cmd;
 	return status;
 }
 
@@ -2031,6 +2038,7 @@
 	qspi_reg->QSPI_AES_KEY_8_B = *key++;
 	qspi_reg->QSPI_AES_KEY_C_F = *key;
 	qspi_reg->OCTA_SPI_BUS_CONTROLLER2 |= EN_SECURITY; // enabling security
+	(void) kh_enable;
 }
 void qspi_qspiload_nonce(qspi_reg_t *qspi_reg, uint32_t *nonce)
 {
--- ./Peripheral_Library/driver/src/rsi_sdioh.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/src/rsi_sdioh.c	2019-04-17 14:51:12.430117065 +0100
@@ -856,7 +856,7 @@
 	status_t     Stat   = RSI_SDIOH_ERROR;
 
 	CmdData.cmdIdx         = CMD11;
-	CmdData.cmdArg         = 0;
+	CmdData.cmdArg         = CmdArg;
 	CmdData.data           = NULL;
 	CmdData.blockSize      = 0;
 	CmdData.blockCount     = 0;
@@ -865,7 +865,7 @@
 
 	/* Send Command */
 	Stat = RSI_SDIOH_SendCommand(&CmdData);
-
+	(void) pcmdInfo;
 	return Stat;
 }
 
@@ -914,7 +914,7 @@
 
 	/*Send Command*/
 	Stat = RSI_SDIOH_SendCommand(&CmdData);
-
+	(void) pcmdInfo;
 	return Stat;
 }
 
@@ -1025,7 +1025,7 @@
 	status_t       Stat  = RSI_SDIOH_ERROR;
 
 	CmdData.cmdIdx        = CMD5;
-	CmdData.cmdArg        = *(uint32_t *)(&pcmdInfo->ocr);
+	CmdData.cmdArg        = pcmdInfo->ocrv;
 	if(pSdiohConfig->voltage ==1)
 	{
 		//voltage switch request
@@ -1064,7 +1064,7 @@
 	status_t        Stat  = RSI_SDIOH_ERROR;
 
 	CmdData.cmdIdx           = CMD5;
-	CmdData.cmdArg           = *(uint32_t *)&pcmdInfo->ocr;
+	CmdData.cmdArg           = pcmdInfo->ocrv;
 	CmdData.cmdArg           = (CmdData.cmdArg & 0x00000000);
 	CmdData.data             = NULL;
 	CmdData.blockSize        = 0;
@@ -1470,11 +1470,7 @@
 
 #define SD_IRQHandler                IRQ068_Handler
 
-SDIOH_INSTANCE_INTERNAL_DATA_T SdiohData =
-{
-		0u,
-		0u,
-};
+SDIOH_INSTANCE_INTERNAL_DATA_T SdiohData;
 
 static SDIOH_INTERN_DATA_T* SdiohGetInternDataPtr() 
 {
@@ -2070,10 +2066,13 @@
  */
 status_t sdioh_send_command( SDIOH_COMMAND_CONFIG_T* pConfig )
 {
-	SDIOH_COMMAND_FIELD_T CmdData;
+	union {
+		SDIOH_COMMAND_FIELD_T CmdData;
+		uint16_t CmdDatav;
+	} cmd;
 
 	// Clear structure
-	memset(&CmdData, 0, sizeof(CmdData));
+	memset(&cmd, 0, sizeof(cmd));
 
 	// Check for NULL pointer
 	if (pConfig == 0)
@@ -2085,16 +2084,16 @@
 	switch (pConfig->cmdType)
 	{
 	case NORMAL_CMD:
-		CmdData.cmdType = 0u;
+		cmd.CmdData.cmdType = 0u;
 		break;
 	case SUSPEND_CMD:
-		CmdData.cmdType = 1u;
+		cmd.CmdData.cmdType = 1u;
 		break;
 	case RESUME_CMD:
-		CmdData.cmdType = 2u;
+		cmd.CmdData.cmdType = 2u;
 		break;
 	case  ABORT_CMD:
-		CmdData.cmdType = 3u;
+		cmd.CmdData.cmdType = 3u;
 		break;
 	default:
 		return RSI_SDIOH_INVALID_PARAMETER ;
@@ -2103,54 +2102,54 @@
 	// Set data present during the command    
 	if(pConfig->dataPresent == 1)
 	{
-		CmdData.dataPresentSelect = 0x1;
+		cmd.CmdData.dataPresentSelect = 0x1;
 	}
 	else
 	{
-		CmdData.dataPresentSelect = 0x0;
+		cmd.CmdData.dataPresentSelect = 0x0;
 	}
 
 	// Set command index check 
 	if(pConfig->checkCmdIndex == 1)
 	{
-		CmdData.cmdIndexCheckEnable = 0x1;
+		cmd.CmdData.cmdIndexCheckEnable = 0x1;
 	}
 	else
 	{
-		CmdData.cmdIndexCheckEnable  = 0x0;
+		cmd.CmdData.cmdIndexCheckEnable  = 0x0;
 	}
 
 	// Set command CRC check
 	if(pConfig->checkCmdCrc ==1)
 	{
-		CmdData.cmdCrcCheckEnable = 0x1; 
+		cmd.CmdData.cmdCrcCheckEnable = 0x1; 
 	}
 	else
 	{
-		CmdData.cmdCrcCheckEnable = 0x0;
+		cmd.CmdData.cmdCrcCheckEnable = 0x0;
 	}
 
 	// Set command response type
 	switch (pConfig->responseType)
 	{
 	case SDIOH_RESPONSE_NONE:
-		CmdData.respType = 0u;
+		cmd.CmdData.respType = 0u;
 		break;
 	case SDIOH_RESPONSE_136BIT:
-		CmdData.respType = 1u;
+		cmd.CmdData.respType = 1u;
 		break;
 	case SDIOH_RESPONSE_48BIT:
-		CmdData.respType = 2u;
+		cmd.CmdData.respType = 2u;
 		break;
 	case SDIOH_RESPONSE_48BIT_BUSY_CHECK:
-		CmdData.respType = 3u;
+		cmd.CmdData.respType = 3u;
 		break;
 	default:
 		return RSI_SDIOH_INVALID_PARAMETER ;            
 	}
 
 	// Set command index
-	CmdData.cmdIndex = pConfig->cmdIndex;
+	cmd.CmdData.cmdIndex = pConfig->cmdIndex;
 
 	// Auto command setting
 	switch (pConfig->autoCmdType)
@@ -2180,7 +2179,7 @@
 	}
 	// Write command  to the hardware register (Command is sent)
 	//according to the spec, this register should be  write only once.
-	SDIOH->SMIH_COMMAND_REGISTER = *((uint16_t *)&CmdData);
+	SDIOH->SMIH_COMMAND_REGISTER = cmd.CmdDatav;
 
 	return RSI_SDIOH_OK;
 }
--- ./Peripheral_Library/driver/src/rsi_sio.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/src/rsi_sio.c	2019-04-17 14:51:12.430117065 +0100
@@ -67,6 +67,7 @@
 {
 	/*SIO CLock enable */
 	RSI_SIO_ClockEnable();
+	(void) pstcSio;
 	return RSI_OK;
 }
 
@@ -863,7 +864,7 @@
 		}
 		u8Parity = RSI_SIO_UartGetParity(u16Data);
 
-		if(u8Parity == u16UartDataFrame >> (u8DataLen + 1));
+		if(u8Parity == u16UartDataFrame >> (u8DataLen + 1))
 		{
 			return u16Data;
 		}
@@ -884,7 +885,7 @@
 		}
 		return u16Data;
 	}
-
+	(void) u8StopBits;
 	return RSI_OK;
 }
 
@@ -931,6 +932,7 @@
 		gstcSioCb.uart_sio.pvUartRx = ((uint16_t *) data);
 	}
 	gstcSioCb.uart_sio.u16UartRxCnt = numBytes;
+	(void) pstcSio;
 	return RSI_OK;
 }
 
@@ -957,7 +959,7 @@
 	gstcSioCb.uart_sio.u16UartRxCnt = numBytes;
 
 	while(gstcSioCb.uart_sio.enRxStatus == SioUartIdle);
-
+	(void) pstcSio;
 	return RSI_OK;
 }
 
@@ -1345,6 +1347,7 @@
 	}
 	//RSI_SIO_I2cGenerateStop(pstcSio);
 	//arm_print("R D \n");
+	(void) pstcConfig;
 	return RSI_OK ;
 
 
@@ -1455,6 +1458,8 @@
 	//RSI_SIO_I2cGenerateStop(pstcConfig);
 
 	//arm_print("W: D \n");
+	(void) u8PtrRxDat;
+	(void) u16RxLen;
 	return RSI_OK;
 }
 
--- ./Peripheral_Library/driver/src/rsi_udma.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/src/rsi_udma.c	2019-04-17 14:51:12.430117065 +0100
@@ -393,6 +393,7 @@
     /* the number of items remaining to transfer */
     return (transferSize + 1);	
 	}
+	(void) vsUDMAChaConfigData;
 	return RSI_OK;
 }
  
@@ -501,6 +502,7 @@
 			PERIPHERAL_UDMA_DMA_SEL |= SET_BIT(7);
 			break;	
 	}
+	(void) pHandle;
 }	
 
 /* This API is used to configures required parameters for a channel */
--- ./Peripheral_Library/driver/src/rsi_wurx.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/driver/src/rsi_wurx.c	2019-04-17 14:51:12.430117065 +0100
@@ -270,13 +270,13 @@
    {
 		 /* get 64 bit tail data */
      while(!(WURX_CORR_DET_READ_REG & BIT(16)));
-	   RSI_WURX_ReadPattern1Odd(tail_data);
+     RSI_WURX_ReadPattern1Odd(tail_data);
    }
    else if(tail_data_len==TAIL_DATA_DECODE_128BIT)
    {
 		 /* get 128 bit tail data */		 
      while(!(WURX_CORR_DET_READ_REG & BIT(17)));
-	   RSI_WURX_ReadPattern1Odd(tail_data);		
+     RSI_WURX_ReadPattern1Odd(tail_data);		
      while(!(WURX_CORR_DET_READ_REG & BIT(16)));
      RSI_WURX_ReadPattern1Even(tail_data);
    }
@@ -284,21 +284,21 @@
    {
 		 /* get 192 bit tail data */		 
      while(!(WURX_CORR_DET_READ_REG & BIT(17)));
-	   RSI_WURX_ReadPattern1Odd(tail_data);		
+     RSI_WURX_ReadPattern1Odd(tail_data);		
      while(!(WURX_CORR_DET_READ_REG & BIT(16)));
      RSI_WURX_ReadPattern1Even(tail_data);
      while(!(WURX_CORR_DET_READ_REG & BIT(15)));
-	   RSI_WURX_ReadPattern2Odd(tail_data);	
+     RSI_WURX_ReadPattern2Odd(tail_data);	
    } 	
    else if(tail_data_len==TAIL_DATA_DECODE_256BIT)
    {	
 		 /* get 256 bit tail data */		 
      while(!(WURX_CORR_DET_READ_REG & BIT(17)));
-	   RSI_WURX_ReadPattern1Odd(tail_data);
+     RSI_WURX_ReadPattern1Odd(tail_data);
      while(!(WURX_CORR_DET_READ_REG & BIT(16)));
      RSI_WURX_ReadPattern1Even(tail_data);
      while(!(WURX_CORR_DET_READ_REG & BIT(15)));
-	   RSI_WURX_ReadPattern2Odd(tail_data);	
+     RSI_WURX_ReadPattern2Odd(tail_data);	
      while(!(WURX_CORR_DET_READ_REG & BIT(14)));
      RSI_WURX_ReadPattern2Even(tail_data);
    }		
--- ./Peripheral_Library/systemlevel/src/rsi_bod.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/systemlevel/src/rsi_bod.c	2019-04-17 14:51:12.430117065 +0100
@@ -20,7 +20,6 @@
  * Includes
  */
 #include "rsi_chip.h"
-#include "rsi_board.h" 
 #include "rsi_bod.h"
 
 volatile uint32_t batt_status_check ;
@@ -39,8 +38,8 @@
  */
 float RSI_BOD_SoftTriggerGetBatteryStatus(void) 
 {
-	volatile static  uint32_t batt_status,batt_status_supply = 0;
-	volatile static  float vbatt = 0 ;
+	volatile uint32_t batt_status,batt_status_supply = 0;
+	volatile float vbatt = 0 ;
 
 	/*disable the BOD interrupt  */
 	RSI_BOD_IntrEnable(DISABLE);
@@ -63,6 +62,7 @@
 #else
 	/* converts the battery status to vbatt voltage value*/	
 	vbatt = BOD_VBATT_COMPUT_FIRST_ELEMENT * (BOD_VBATT_COMPUT_SECOND_ELEMENT + batt_status) / (BOD_VBATT_COMPUT_SECOND_ELEMENT+ BOD_VBATT_COMPUT_THIRD_ELEMENT) ;
+	(void) batt_status_supply;
 #endif
 
 	/*clr  the BOD interrupt  */
@@ -80,8 +80,8 @@
  */
 float RSI_BOD_PeriodicTriggerGetBatteryStatus(void) 
 {
-	volatile static  uint32_t batt_status =0 ;
-	volatile static  float vbatt = 0;
+	volatile uint32_t batt_status =0 ;
+	volatile float vbatt = 0;
 	/* Enable's the power gating for calibration block  and enable's the periodic trigger   */
 	ULP_SPI_MEM_MAP(BOD_VBATT_STATUS_REG) |= BOD_PWRGATE_EN_N_ULP_BUTTON_CALIB| (PERIODIC_TRIGGER_EN) 	; 
 	/* Wait for vbatt status valid bit to be 1. */
@@ -120,9 +120,9 @@
  */
 void RSI_BOD_Enable(uint8_t enable,float vbatt_threshold)
 {
-	volatile static uint32_t threshold_i = 0 ;
-	volatile static float  threshold_f = 0;
-	volatile  uint32_t delay_button = 0,button_loop = 0 ;
+	volatile uint32_t threshold_i = 0 ;
+	volatile float  threshold_f = 0;
+	volatile uint32_t delay_button = 0,button_loop = 0 ;
 	if (enable==1)
 	{
 		/* Enable signal for bod detection */
@@ -237,7 +237,7 @@
  */ 
 error_t RSI_BOD_ConfigSlotValue(uint16_t slot_value) 
 {
-	if(slot_value == SLOT_MIN_VALUE | slot_value > SLOT_MAX_VALUE )
+	if(slot_value == SLOT_MIN_VALUE || slot_value > SLOT_MAX_VALUE )
 	{  
 		return INVALID_PARAMETERS;  
 	}
@@ -260,7 +260,7 @@
 void RSI_BOD_ButtonWakeUpEnable(uint8_t enable)
 {
 
-	volatile  uint32_t delay_button = 0,button_loop = 0 ,division_factor =0;
+	volatile  uint32_t delay_button = 0,button_loop = 0;
 	if(enable ==1 )
 	{
 		/*To set the NPSS GPIO[2] in analog mode (TO GIVE VOLTAGE SUPPLY THROUGH PIN) */
@@ -321,7 +321,7 @@
  */
 uint32_t RSI_BOD_Buttonvalue(void)
 {
-	volatile static uint32_t buton_value =0 ;
+	volatile uint32_t buton_value =0 ;
 	/* To read which button has set to one */
 	buton_value =(((ULP_SPI_MEM_MAP(BOD_VBATT_STATUS_REG)) &(READ_BUTTON_VALUE_BITS)) >> 16) ;
 	if(buton_value == BUTTON_THREE_VALUE)
--- ./Peripheral_Library/systemlevel/src/rsi_ipmu.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/systemlevel/src/rsi_ipmu.c	2019-04-17 14:51:12.430117065 +0100
@@ -388,7 +388,7 @@
 	while(i--);
 	do {
 		/*wait for calibration done indication*/
-	} while (!(ULP_SPI_MEM_MAP(0x30C)) & BIT(20));
+	} while (!(ULP_SPI_MEM_MAP(0x30C) & BIT(20)));
 	/*Calibrated trim value*/
 	trim_value = ULP_SPI_MEM_MAP(0x30C);
 	trim_value = (trim_value >> 11);
@@ -459,7 +459,7 @@
  */
 uint32_t RSI_APB_ProgramConfigData(uint32_t *config)
 {
-	volatile uint32_t index = 0 , program_len = 0 ,reg_addr = 0 ;
+	volatile uint32_t index = 0 , program_len = 0;
 	volatile uint32_t clear_cnt=0,cnt=0 ;
 	volatile uint32_t reg_write_data=0,reg_read_data=0 , write_mask=0 , write_bit_pos=0;
 	volatile uint8_t  msb=0 , lsb=0 ;
--- ./Peripheral_Library/systemlevel/src/rsi_pll.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/systemlevel/src/rsi_pll.c	2019-04-17 14:51:12.430117065 +0100
@@ -25,7 +25,7 @@
  */
 #include<math.h> 
 #include "rsi_chip.h" 
-#include "..\driver\src\clock_update.c"
+#include "clock_update.h"
 
 /*clock sources preset */
 typedef enum CLK_PRESENT
--- ./Peripheral_Library/systemlevel/src/rsi_time_period.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/systemlevel/src/rsi_time_period.c	2019-04-17 14:51:12.434117277 +0100
@@ -204,7 +204,7 @@
 		/*Update at which temperature calibration has to happen*/
 		pstcTimePeriod->MCU_CAL_TEMP_PROG_REG_b.MAX_TEMP_CHANGE = u8TemperatureVal;
 	}
-
+	(void) u32XtalSettle;
 	return RSI_OK;
 }
 
--- ./Peripheral_Library/systemlevel/src/rsi_wwdt.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Peripheral_Library/systemlevel/src/rsi_wwdt.c	2019-04-17 14:51:12.434117277 +0100
@@ -29,6 +29,7 @@
 {
   RSI_PS_NpssPeriPowerUp(SLPSS_PWRGATE_ULP_MCUWDT |	SLPSS_PWRGATE_ULP_TIMEPERIOD);
 	MCU_FSM->MCU_FSM_CRTL_PDM_AND_ENABLES_b.ENABLE_WDT_IN_SLEEP_b = 1;
+	(void) pstcWDT;
 }
 
 /**
--- ./Wireless_Library/common/rsi_common_apis.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/common/rsi_common_apis.c	2019-04-17 14:51:12.434117277 +0100
@@ -35,6 +35,8 @@
 #include "rsi_wlan_non_rom.h"
 extern rsi_socket_info_non_rom_t *rsi_socket_pool_non_rom;
 
+extern void rom_init(void);
+
 /*
  * Global Variables
  * */
@@ -147,7 +149,7 @@
   //! Allocate memory for driver cb
   rsi_driver_cb = (rsi_driver_cb_t *)buffer;
   buffer += sizeof(rsi_driver_cb_t);
-#ifdef RSI_WLAN_ENABLE
+#if defined(RSI_WLAN_ENABLE) && RSI_NUMBER_OF_SOCKETS > 0
   //! Memory for sockets
   rsi_socket_pool = (rsi_socket_info_t *)buffer;
   buffer += RSI_SOCKET_INFO_POOL_SIZE; 
@@ -352,7 +354,9 @@
   }
 #endif 
 
-  return actual_length;
+  (void) status;
+
+  return RSI_SUCCESS;
 }
 
 /*==============================================*/
@@ -377,7 +381,7 @@
   rsi_opermode_t *rsi_opermode;
   int32_t        status = RSI_SUCCESS;
 #ifdef RSI_M4_INTERFACE	
-  int32_t        ipmu_status = RSI_SUCCESS;
+  //int32_t        ipmu_status = RSI_SUCCESS;
 
 #endif
   //! Get common cb pointer
@@ -867,6 +871,7 @@
  * This Function is used to select the socket comfiguration
  *
  */
+#if RSI_NUMBER_OF_SOCKETS > 0
 int32_t rsi_socket_config()
 {
 
@@ -937,6 +942,7 @@
   return status;
 
 }
+#endif // RSI_NUMBER_OF_SOCKETS > 0
 
 /*==============================================*/
 /**
--- ./Wireless_Library/common/rsi_device_init_apis.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/common/rsi_device_init_apis.c	2019-04-17 14:51:12.434117277 +0100
@@ -21,21 +21,21 @@
 /**
  * Includes
  */
-#include "rsi_driver.h"
 #ifdef SIM_9118
 #include "rsi_board.h"
 #endif
 #ifdef RSI_M4_INTERFACE
 #ifdef ROM_WIRELESS
 #include "rsi_chip.h"
-#include "rsi_board.h"
 #endif
+#include "rsi_api.h"
 #include "core_cm4.h"
 #endif
 #ifdef LINUX_PLATFORM
 #include<stdint.h>
 #include <sys/ioctl.h>
 #endif
+#include "rsi_driver.h"
 /*==============================================*/
 /**
  * @fn      int32_t rsi_bl_module_power_on(void)
@@ -130,7 +130,9 @@
   int32_t retval=0;
 #ifdef RSI_M4_INTERFACE
 
+#ifndef RSI_WITH_OS
   SysTick_Config(SystemCoreClock / 1000);
+#endif
   if(!(P2P_STATUS_REG & TA_is_active))
   {
 #ifdef DEBUG_UART
@@ -261,6 +263,8 @@
   rsi_hal_intr_unmask();
 #endif
 
+  (void) timer_instance;
+
   return status;
 }
 
--- ./Wireless_Library/driver/rsi_common.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/driver/rsi_common.c	2019-04-17 14:51:12.434117277 +0100
@@ -987,6 +987,7 @@
     rsi_semaphore_post(&rsi_driver_cb->common_cb->common_sem);
 
   }
+  (void) pkt;
 }
 
 
--- ./Wireless_Library/driver/rsi_driver_event_handlers.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/driver/rsi_driver_event_handlers.c	2019-04-17 14:51:12.434117277 +0100
@@ -134,7 +134,7 @@
   rsi_req_wakeup();
 #endif
 #else
-#if (RSI_ULP_MODE == 1)
+#if !defined(RSI_M4_INTERFACE) && (RSI_ULP_MODE == 1)
       rsi_ulp_wakeup_init();
 #endif
 #endif
--- ./Wireless_Library/driver/rsi_nwk.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/driver/rsi_nwk.c	2019-04-17 14:51:12.434117277 +0100
@@ -91,7 +91,7 @@
 uint16_t rsi_nwk_register_callbacks(rsi_nwk_callback_id_t callback_id, void (*callback_handler_ptr)(uint8_t command_type , uint32_t status, const uint8_t *buffer, const uint32_t length))
 {
 
-  if(callback_id > RSI_MAX_NUM_CALLBACKS)
+  if(callback_id >= RSI_NWK_MAX_NUM_CALLBACKS)
   {
     /*
      *Return , if the callback number exceeds the RSI_MAX_NUM_CALLBACKS ,or
@@ -125,7 +125,7 @@
 
 uint16_t rsi_wlan_nwk_register_json_update_cb(uint32_t callback_id, void (*callback_handler_ptr)(uint8_t *filename, uint8_t *json_object, uint32_t length, uint32_t status))
 {
-  if(callback_id > RSI_MAX_NUM_CALLBACKS)
+  if(callback_id >= RSI_NWK_MAX_NUM_CALLBACKS)
   {
     /*
      *Return , if the callback number exceeds the RSI_MAX_NUM_CALLBACKS ,or
@@ -144,7 +144,7 @@
 
 uint16_t rsi_wlan_nwk_register_json_event_cb(uint32_t callback_id, void (*callback_handler_ptr)(uint32_t status, uint8_t *json_object, uint32_t length))
 {
-  if(callback_id > RSI_MAX_NUM_CALLBACKS)
+  if(callback_id >= RSI_NWK_MAX_NUM_CALLBACKS)
   {
     /*
      *Return , if the callback number exceeds the RSI_MAX_NUM_CALLBACKS ,or
@@ -161,7 +161,7 @@
 
 uint16_t rsi_wlan_nwk_register_webpage_req_cb(uint32_t callback_id, void (*callback_handler_ptr)(uint8_t type, uint8_t *url_name, uint8_t *post_content_buffer, uint32_t post_content_length, uint32_t status))
 {
-  if(callback_id > RSI_MAX_NUM_CALLBACKS)
+  if(callback_id >= RSI_NWK_MAX_NUM_CALLBACKS)
   {
     /*
      *Return , if the callback number exceeds the RSI_MAX_NUM_CALLBACKS ,or
@@ -178,7 +178,7 @@
 
 uint16_t rsi_wlan_nwk_register_wireless_fw_upgrade_cb(uint32_t callback_id, void (*callback_handler_ptr)(uint8_t type, uint32_t status))
 {
-  if(callback_id > RSI_MAX_NUM_CALLBACKS)
+  if(callback_id >= RSI_NWK_MAX_NUM_CALLBACKS)
   {
     /*
      *Return , if the callback number exceeds the RSI_MAX_NUM_CALLBACKS ,or
--- ./Wireless_Library/driver/rsi_utils.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/driver/rsi_utils.c	2019-04-17 14:51:12.434117277 +0100
@@ -367,7 +367,7 @@
  */
 void string2array(uint8_t *dst, uint8_t *src, uint32_t length)
 {
-  int i = 0,j = 0;
+  uint32_t i = 0,j = 0;
   for(i=0 ,j=0 ; i < (length * 2) && j < length; i+=2,j++)
   {
     if(src[i] && src[i + 1])
--- ./Wireless_Library/driver/rsi_wlan.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/driver/rsi_wlan.c	2019-04-24 13:01:22.013030552 +0100
@@ -100,6 +100,8 @@
   //! Get host descriptor pointer
   uint8_t *host_desc = (pkt->desc);
 
+  LOG(LL_DEBUG, ("WLAN CMD: 0x%x", cmd));
+
   switch(cmd)
   {
     case RSI_WLAN_REQ_BAND:
@@ -356,7 +358,7 @@
         rsi_req_roam_params_t *rsi_roam_params = (rsi_req_roam_params_t *)pkt->data;
 
         //! Enable or Disable bg scan 
-        rsi_uint32_to_4bytes(rsi_roam_params->roam_enable, RSI_ROAMING_SUPPORT);
+        rsi_uint32_to_4bytes(rsi_roam_params->roam_enable, RSI_ROAMING_ENABLE);
 
         //! Enable or Disable instant bg scan 
         rsi_uint32_to_4bytes(rsi_roam_params->roam_threshold, RSI_ROAMING_THRESHOLD);
@@ -432,7 +434,7 @@
       }
       break;
 
-     
+#if RSI_NUMBER_OF_SOCKETS > 0
     case RSI_WLAN_REQ_SOCKET_CREATE:
       {
         //! Socket Parameters
@@ -479,6 +481,7 @@
         payload_size = sizeof(rsi_req_socket_read_t);
       }
       break;
+#endif // RSI_NUMBER_OF_SOCKETS > 0
     case RSI_WLAN_REQ_SET_CERTIFICATE:
       {
         rsi_req_set_certificate_t *set_certificate = (rsi_req_set_certificate_t *)pkt->data;
@@ -725,12 +728,14 @@
         payload_size = sizeof(rsi_auto_config_enable_t);
       }
       break;
+#if RSI_NUMBER_OF_SOCKETS > 0
     case RSI_WLAN_REQ_SOCKET_CONFIG:
       {
         //! fill payload size
         payload_size = sizeof(rsi_socket_config_t);
       }
       break;
+#endif
 #ifdef RSI_WAC_MFI_ENABLE
     case RSI_WLAN_REQ_ADD_MFI_IE:
       {
@@ -746,6 +751,7 @@
         payload_size = sizeof(rsi_req_wlan_filter_bcast_t);
 
       }
+      break;
     case  RSI_WLAN_REQ_SNTP_CLIENT:
       {
          //! fill payload size
@@ -864,6 +870,17 @@
     return &json[i+1];
 }
 
+void rsi_wlan_connect_async_mgos(void *arg) {
+  rsi_wlan_async_connect_ctx_t *ctx = (rsi_wlan_async_connect_ctx_t *) arg;
+  rsi_wlan_connect_async(ctx->ssid, ctx->sec_type, ctx->secret_key, ctx->join_response_handler);
+  rsi_driver_wlan_free_async_connect_ctx(ctx);
+}
+
+void rsi_driver_wlan_free_async_connect_ctx(rsi_wlan_async_connect_ctx_t *ctx) {
+  memset(ctx, 0, sizeof(*ctx));
+  free(ctx);
+}
+
 /*==============================================*/
 /**
  * @fn          int32_t rsi_driver_process_wlan_recv_cmd(rsi_pkt_t *pkt)
@@ -891,7 +908,6 @@
   uint16_t length;
   uint8_t  buffers_freed;
   int8_t wlan_pkt_pending = 0;
-  uint8_t type;
   //! Get wlan cb struct pointer
   rsi_wlan_cb_t *rsi_wlan_cb = rsi_driver_cb->wlan_cb;
   
@@ -926,6 +942,9 @@
 
   //! check for packet pending in wlan queue
   wlan_pkt_pending = rsi_check_queue_status(&rsi_driver_cb->wlan_tx_q);
+
+  LOG(LL_DEBUG, ("WLAN RSP: 0x%x STATUS: 0x%x", cmd_type, (unsigned int) status));
+
   
   switch(cmd_type)
   {
@@ -1175,6 +1194,31 @@
     case RSI_WLAN_RSP_SCAN:
       {
 
+        if(rsi_wlan_cb->opermode != RSI_WLAN_ACCESS_POINT_MODE &&
+           rsi_wlan_cb->async_connect_ctx != NULL)
+        {
+          //! This scan is part of async join.
+          rsi_wlan_cb->expected_response = RSI_WLAN_RSP_CLEAR;
+
+          rsi_wlan_async_connect_ctx_t *ctx = rsi_wlan_cb->async_connect_ctx;
+
+          rsi_wlan_cb->async_connect_ctx = NULL;
+
+          if(status == RSI_SUCCESS)
+          {
+            rsi_wlan_cb->state = RSI_WLAN_STATE_SCAN_DONE; 
+            // We need to bounce off another task to be able to invoke the API.
+            // This is mos-specific and proper solution would be different.
+            mgos_invoke_cb(rsi_wlan_connect_async_mgos, ctx, false /* from_isr */);
+          }
+          else
+          {
+            ctx->join_response_handler(status, payload, payload_length);
+            rsi_driver_wlan_free_async_connect_ctx(ctx);
+          }
+          return RSI_SUCCESS;
+        }
+
         //! update state  wlan_cb state to scan done
         if(status == RSI_SUCCESS)
         {
@@ -1182,6 +1226,7 @@
           if(rsi_wlan_cb->opermode != RSI_WLAN_ACCESS_POINT_MODE)
           {
             rsi_wlan_cb->state = RSI_WLAN_STATE_SCAN_DONE; 
+
           }
 
           if(rsi_driver_cb->wlan_cb->callback_list.wlan_scan_response_handler != NULL)
@@ -1190,6 +1235,8 @@
             //! Call asynchronous response handler to indicate to host
             rsi_wlan_cb->callback_list.wlan_scan_response_handler(status, payload, payload_length);
 
+            rsi_wlan_cb->callback_list.wlan_scan_response_handler = NULL;
+
             return RSI_SUCCESS;
           }
           else
@@ -1203,11 +1250,26 @@
             }
           }
         }
+        else
+        {
+          if(rsi_driver_cb->wlan_cb->callback_list.wlan_scan_response_handler != NULL)
+          {
+            rsi_wlan_cb->callback_list.wlan_scan_response_handler(status, payload, payload_length);
+
+            rsi_wlan_cb->callback_list.wlan_scan_response_handler = NULL;
+          }
+        }
       }
       break;
     case RSI_WLAN_RSP_BG_SCAN:
       {
-        if(status == RSI_SUCCESS)
+        if(rsi_driver_cb->wlan_cb->callback_list.wlan_scan_response_handler != NULL)
+        {
+          rsi_wlan_cb->callback_list.wlan_scan_response_handler(status, payload, payload_length);
+
+          rsi_wlan_cb->callback_list.wlan_scan_response_handler = NULL;
+        }
+        else if(status == RSI_SUCCESS)
         {
           //! check the length of application buffer and copy bg scan results
           if((rsi_wlan_cb->app_buffer != NULL) && (rsi_wlan_cb->app_buffer_length != 0))
@@ -1262,8 +1324,10 @@
                 rsi_wlan_cb->callback_list.join_fail_handler(status, payload, payload_length);
               }
 
+#if RSI_NUMBER_OF_SOCKETS > 0
               //! Clear all sockets
               rsi_clear_sockets(RSI_CLEAR_ALL_SOCKETS);
+#endif
 
               if((rsi_wlan_check_waiting_socket_cmd() || rsi_wlan_check_waiting_wlan_cmd()) && (wlan_pkt_pending == 0))
               {
@@ -1284,6 +1348,13 @@
           //! Call asynchronous response handler to indicate to host
           rsi_wlan_cb->callback_list.wlan_join_response_handler(status, payload, payload_length);
 
+          // If connected, do not clear the response handler yet,
+          // it will be used when station disconnects.
+          if(status != RSI_SUCCESS)
+          {
+            rsi_wlan_cb->callback_list.wlan_join_response_handler = NULL;
+          }
+
           //! Clear expected response
           rsi_wlan_cb->expected_response = RSI_WLAN_RSP_CLEAR;
 
@@ -1337,8 +1408,10 @@
               rsi_wlan_cb->callback_list.ip_renewal_fail_handler(status, payload, payload_length); 
             }
 
+#if RSI_NUMBER_OF_SOCKETS > 0
             //! Clear all sockets info
             rsi_clear_sockets(RSI_CLEAR_ALL_SOCKETS);
+#endif
 
             if(rsi_wlan_check_waiting_socket_cmd()  && (wlan_pkt_pending == 0))
             {
@@ -1404,8 +1477,10 @@
           //! Reset module state as Disconnect received
           common_cb->power_save.module_state = 0;
 
+#if RSI_NUMBER_OF_SOCKETS > 0
           //! Clear all sockets
           rsi_clear_sockets(RSI_CLEAR_ALL_SOCKETS);
+#endif
         }
       }
       break;
@@ -1415,7 +1490,7 @@
         status  = rsi_bytes2R_to_uint16(host_desc + RSI_STATUS_OFFSET);
       }
       break;
-
+#if RSI_NUMBER_OF_SOCKETS > 0
     case RSI_WLAN_RSP_SOCKET_CREATE:
       {
         if(status == RSI_SUCCESS)
@@ -1531,7 +1606,7 @@
         }
       }
       break;
-
+#endif // RSI_NUMBER_OF_SOCKETS > 0
     case RSI_WLAN_RSP_IPV4_CHANGE:
       {
         if(rsi_wlan_cb->callback_list.ip_change_notify_handler != NULL)
@@ -1540,8 +1615,10 @@
           rsi_wlan_cb->callback_list.ip_change_notify_handler(status, payload, payload_length); 
         }
 
+#if RSI_NUMBER_OF_SOCKETS > 0
         //! Clear all sockets info
         rsi_clear_sockets(RSI_CLEAR_ALL_SOCKETS);
+#endif
 
         if(rsi_wlan_check_waiting_socket_cmd() && (wlan_pkt_pending == 0))
         {
@@ -1615,7 +1692,7 @@
           if(status == RSI_SUCCESS)
           {
             //! Call asynchronous response handler to indicate to host
-             rsi_driver_cb->nwk_cb->nwk_callbacks.rsi_webpage_request_handler(type, postcontent->url_name, postcontent->post_data, (uint32_t)postcontent->post_content_length, status);
+             rsi_driver_cb->nwk_cb->nwk_callbacks.rsi_webpage_request_handler(cmd_type, postcontent->url_name, postcontent->post_data, (uint32_t)postcontent->post_content_length, status);
           }
 
         }
@@ -1673,6 +1750,7 @@
       break;
 
 
+#if RSI_NUMBER_OF_SOCKETS > 0
     case RSI_WLAN_RSP_TCP_ACK_INDICATION:
       {
         rsi_rsp_tcp_ack_t *tcp_ack = (rsi_rsp_tcp_ack_t *)payload; 
@@ -1709,6 +1787,7 @@
 
       }
       break;
+#endif // RSI_NUMBER_OF_SOCKETS > 0
     case RSI_WLAN_RSP_WIRELESS_FWUP_OK:
     case RSI_WLAN_RSP_WIRELESS_FWUP_DONE:
       {
@@ -1839,7 +1918,7 @@
           return RSI_SUCCESS;
         }
       }
-
+      break;
     case RSI_WLAN_RSP_UART_DATA_ACK:
       {
         //! check wlan_cb for any task is waiting for response
@@ -1896,6 +1975,13 @@
 	      }
       }
       break;
+      case RSI_WLAN_RSP_STATE_NOTIFICATION:
+      {
+        if (rsi_driver_cb->wlan_cb->callback_list.wlan_state_notification_handler != NULL) {
+          rsi_driver_cb->wlan_cb->callback_list.wlan_state_notification_handler(status, payload, payload_length);
+        }
+      }
+      break;
     default:
       break;
   }
@@ -1909,6 +1995,12 @@
     rsi_semaphore_post(&rsi_wlan_cb->wlan_sem);
   }
 
+  (void) buffers_freed;
+  (void) length;
+  (void) sock_id;
+  (void) sockID;
+  (void) ip_version;
+
   return RSI_SUCCESS;
 }
 
@@ -1996,6 +2088,7 @@
           return status;
         }
       }
+      // fall through
     case RSI_WLAN_STATE_BAND_DONE:
       {
 
@@ -2295,7 +2388,7 @@
   if(rsi_wlan_cb->callback_list.wlan_data_receive_handler != NULL)
   {
     //! Call asynchronous data receive handler to indicate to host
-    rsi_wlan_cb->callback_list.wlan_data_receive_handler( 0, payload, payload_length);
+    rsi_wlan_cb->callback_list.wlan_data_receive_handler( status, payload, payload_length);
   }
 
 }
@@ -2329,6 +2422,7 @@
     rsi_semaphore_post(&rsi_driver_cb->wlan_cb->wlan_sem);
 
   }
+  (void) pkt;
 }
 
 
@@ -2360,6 +2454,7 @@
     rsi_semaphore_post(&rsi_driver_cb->wlan_cb->wlan_sem);
 
   }
+  (void) pkt;
 }
 
 /*==============================================*/
@@ -2390,4 +2485,5 @@
     rsi_semaphore_post(&rsi_driver_cb->wlan_cb->wlan_sem);
 
   }
+  (void) pkt;
 }
--- ./Wireless_Library/hal_WiSeMcu/inc/rsi_api.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/hal_WiSeMcu/inc/rsi_api.h	2019-04-17 14:51:12.434117277 +0100
@@ -106,7 +106,7 @@
 #define RSI_SUCCESS                        0
 #define RSI_BUSY                           -1
 #define RSI_FAIL                           -2
-#define RSI_BUFFER_FULL                    -3
+// #define RSI_BUFFER_FULL                    -3
 #define RSI_IN_SLEEP                       -4
 
 
--- ./Wireless_Library/hal_WiSeMcu/inc/rsi_m4.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/hal_WiSeMcu/inc/rsi_m4.h	2019-04-17 14:51:12.434117277 +0100
@@ -196,7 +196,9 @@
 void ROM_WL_mask_ta_interrupt(uint32_t interrupt_no);
 void ROM_WL_unmask_ta_interrupt(uint32_t interrupt_no);
 void ROM_WL_clear_ta_to_m4_interrupt(uint32_t interrupt_no);
-
+void rsi_config_m4_dma_desc_on_reset();
+void rsi_update_rx_dma_desc();
+void rsi_update_tx_dma_desc(uint8_t skip_dma_valid);
 
 #endif
 #endif
--- ./Wireless_Library/hal_WiSeMcu/src/rsi_bootup_config.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/hal_WiSeMcu/src/rsi_bootup_config.c	2019-04-17 14:51:12.434117277 +0100
@@ -44,8 +44,7 @@
  */
 int16_t rsi_mem_wr(uint32_t addr, uint16_t len, uint8_t *dBuf)
 {
-	 *(uint32_t *)addr =  *(uint32_t *)dBuf;
- 
+    memcpy((void *) addr, dBuf, len);
     return 0;
 }
 
@@ -67,8 +66,8 @@
  */
 int16_t rsi_mem_rd(uint32_t addr, uint16_t len, uint8_t *dBuf)
 {
-	 *(uint32_t *)dBuf =  *(uint32_t *)addr;
-   return 0;
+    memcpy(dBuf, (void *) addr, len);
+    return 0;
 }
 
 
@@ -94,7 +93,7 @@
   uint32_t  j = 0;
   uint32_t  cmd = 0; 
   uint16_t  read_data = 0;
-  volatile int32_t  loop_counter = 0;
+  uint32_t  loop_counter = 0;
 #ifdef RSI_DEBUG_PRINT
   RSI_DPRINT(RSI_PL3,"\nBootInsn\n");
 #endif
@@ -291,7 +290,7 @@
   int16_t    retval = 0;
   uint16_t   read_value = 0;
   uint8_t    image_number  = 0;
-  volatile int32_t  loop_counter = 0;
+  uint32_t  loop_counter = 0;
 
   boot_cmd = HOST_INTERACT_REG_VALID | cmd;
   if(cmd == RSI_CHECK_CRC)
--- ./Wireless_Library/hal_WiSeMcu/src/rsi_hal_mcu_m4.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/hal_WiSeMcu/src/rsi_hal_mcu_m4.c	2019-04-17 14:51:12.434117277 +0100
@@ -21,9 +21,6 @@
 #ifdef RSI_M4_INTERFACE
 #include "rsi_driver.h"
 #include "rsi_m4.h"
-#ifdef ROM_WIRELESS
-#include "rsi_board.h"
-#endif
 
 rsi_m4ta_desc_t tx_desc[2];
 rsi_m4ta_desc_t rx_desc[2];
@@ -199,7 +196,7 @@
   {
     while(M4_TX_DMA_DESC_REG & DMA_DESC_REG_VALID);
   }
-  M4_TX_DMA_DESC_REG = (uint32_t)&tx_desc;
+  M4_TX_DMA_DESC_REG = ((uint32_t) &tx_desc) & ~M4_MEMORY_OFFSET_ADDRESS;
 }
 
 /*==============================================*/
@@ -216,7 +213,7 @@
  */
 void rsi_update_rx_dma_desc()
 {
-	M4_RX_DMA_DESC_REG = (uint32_t)&rx_desc;
+  M4_RX_DMA_DESC_REG = ((uint32_t) &rx_desc) & ~M4_MEMORY_OFFSET_ADDRESS;
 }
 
 
@@ -241,8 +238,8 @@
   //! Wait for TA to wakeup and should be in bootloader
   while(!(P2P_STATUS_REG & TA_is_active));
   //! UPdate M4 TX and RX dma descriptors
-  M4_TX_DMA_DESC_REG = (uint32_t)&tx_desc;
-  M4_RX_DMA_DESC_REG = (uint32_t)&rx_desc;
+  M4_TX_DMA_DESC_REG = ((uint32_t) &tx_desc) & ~M4_MEMORY_OFFSET_ADDRESS;
+  M4_RX_DMA_DESC_REG = ((uint32_t) &rx_desc) & ~M4_MEMORY_OFFSET_ADDRESS;
 }
 
 
--- ./Wireless_Library/include/rsi_common_apis.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/include/rsi_common_apis.h	2019-04-17 14:51:12.434117277 +0100
@@ -41,8 +41,12 @@
 #define RSI_LOAD_IMAGE_I_FW                  '1'
 #define RSI_LOAD_IMAGE_I_ACTIVE_LOW_FW       0x71
 
-//! Upgrade images
-#define RSI_UPGRADE_IMAGE_I_FW               'B'
+#ifdef RS9116
+//! Upgrade Image types
+#define RSI_UPGRADE_IMAGE_I_FW           'B'
+#else
+#define RSI_UPGRADE_IMAGE_I_FW           '2'
+#endif
 
 
 //! Upgrade images
--- ./Wireless_Library/include/rsi_common.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/include/rsi_common.h	2019-04-17 14:51:12.434117277 +0100
@@ -266,7 +266,7 @@
 typedef struct rsi_common_cb_s
 {
   //! driver common block state 
-  rsi_common_state_t state;
+  volatile rsi_common_state_t state;
 
   //! driver common block status
   volatile int32_t status;
--- ./Wireless_Library/include/rsi_nwk.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/include/rsi_nwk.h	2019-04-17 14:51:12.434117277 +0100
@@ -132,7 +132,8 @@
   RSI_WLAN_NWK_URL_REQ_CB                    =   1,
   RSI_WLAN_NWK_JSON_UPDATE_CB                =   2,
   RSI_WLAN_NWK_FW_UPGRADE_CB                 =   3,
-  RSI_WLAN_NWK_JSON_EVENT_CB                 =   4
+  RSI_WLAN_NWK_JSON_EVENT_CB                 =   4,
+  RSI_NWK_MAX_NUM_CALLBACKS,
 }rsi_nwk_callback_id_t;
 
 
--- ./Wireless_Library/include/rsi_socket.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/include/rsi_socket.h	2019-04-17 14:51:12.434117277 +0100
@@ -20,6 +20,10 @@
  */
 #ifndef RSI__SOCKET_H
 #define RSI__SOCKET_H
+
+#include <rsi_user.h>
+
+#if RSI_NUMBER_OF_SOCKETS > 0
 /******************************************************
  * *                      Macros
  * ******************************************************/
@@ -109,13 +113,14 @@
 
 #define F_GETFL                             3                       /* Get file descriptors                                                 */
 #define F_SETFL                             4                       /* Set a subset of file descriptors (e.g. O_NONBlOCK                    */
+#ifndef O_NONBLOCK
 #define O_NONBLOCK                          0x4000                  /* Option to enable non blocking on a file (e.g. socket)                */
+#endif
 
 #ifndef FIONBIO
 #define FIONBIO                             0x5421                  /* Enables socket non blocking option for the ioctl() command            */
 #endif
 
-
 /* Define additional BSD socket errors. */
 
 /* From errno-base.h in /usr/include/asm-generic;  */
@@ -256,7 +261,6 @@
 #define ENOTRECOVERABLE 131 /* State not recoverable */
 #define ERFKILL         132 /* Operation not possible due to RF-kill */
 
-
 /* List of BSD sock options from socket.h in /usr/include/asm/socket.h and asm-generic/socket.h.
    The first set of socket options take the socket level (category) SOL_SOCKET. */
 
@@ -410,8 +414,12 @@
   } _S6_un;
 };
 
+#ifndef s6_addr
 #define s6_addr     _S6_un._S6_u8
+#endif
+#ifndef s6_addr32
 #define s6_addr32   _S6_un._S6_u32
+#endif
 
 struct rsi_sockaddr_in6 
 {
@@ -640,4 +648,32 @@
                      void(*data_transfer_complete_handler)(uint8_t sockId, const uint16_t length));
 int rsi_setsockopt(int socket, int level, int option_name,const void *option_value, rsi_socklen_t option_len);
 
+#else
+
+// RSI sockets are disabled, provide just the bare minimum defs.
+
+struct rsi_sockaddr;
+typedef int rsi_socket_info_t;
+#define RSI_TCP_LISTEN_MIN_BACKLOG 0
+#define RSI_IPV4_ADDRESS_LENGTH    4
+#define RSI_IPV6_ADDRESS_LENGTH    16
+
+typedef enum rsi_ip_config_mode_e
+{
+  RSI_STATIC = 0,
+  RSI_DHCP,
+  RSI_DHCP_HOSTNAME,
+  RSI_DHCP_RESERVED,
+  RSI_DHCP_OPTION81,
+  RSI_DHCP_OPTION77
+}rsi_ip_config_mode_t;
+
+typedef enum rsi_ip_version_e
+{
+  RSI_IP_VERSION_4=4,
+  RSI_IP_VERSION_6=6
+}rsi_ip_version_t;
+
+#endif // RSI_NUMBER_OF_SOCKETS > 0
+
 #endif
--- ./Wireless_Library/include/rsi_wlan_apis.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/include/rsi_wlan_apis.h	2019-04-17 18:50:32.918843329 +0100
@@ -61,9 +61,6 @@
 //! MAC address length
 #define RSI_MAC_ADDR_LEN                  6
 
-//! max no of call backs
-#define RSI_MAX_NUM_CALLBACKS            12
-
 //! Maximum wifi direct device count
 #define RSI_MAX_WFD_DEVICE_COUNT          10    
 
@@ -592,7 +589,9 @@
   RSI_WLAN_WFD_CONNECTION_REQUEST_NOTIFY_CB  =   9,
   RSI_WLAN_SCAN_RESPONSE_HANDLER             =   10,
   RSI_WLAN_JOIN_RESPONSE_HANDLER             =   11,
-  RSI_WLAN_RAW_DATA_RECEIVE_HANDLER          =   12
+  RSI_WLAN_RAW_DATA_RECEIVE_HANDLER          =   12,
+  RSI_WLAN_STATE_NOTIFICATION_HANDLER        =   13,
+  RSI_WLAN_MAX_NUM_CALLBACKS,
 }rsi_callback_id_t;
 
 //! enumerations for encryption types 
@@ -1015,6 +1014,15 @@
 } rsi_rsp_scan_t;
 
 
+//! Async connection statue responses
+typedef struct rsi_state_notification_s {
+  uint8_t timestamp[4];
+  uint8_t state_code;
+  uint8_t reason_code;
+  uint8_t channel;
+  uint8_t rssi_val;
+  uint8_t bssid[6];
+} rsi_state_notificaton_t;
 
 
 //! Response structure for Query firmware version command
@@ -1187,10 +1195,10 @@
 /******************************************************
  * *               Function Declarations
  * ******************************************************/
-extern int32_t rsi_wlan_scan(int8_t *ssid, uint8_t chno,rsi_rsp_scan_t *result,uint32_t length);
-extern int32_t rsi_wlan_scan_async(int8_t *ssid, uint8_t chno, void(*callback)(uint16_t status, const uint8_t *buffer, const uint16_t length));
-extern int32_t rsi_wlan_connect(int8_t *ssid, rsi_security_mode_t sec_type, void *secret_key);
-extern int32_t rsi_wlan_connect_async(int8_t *ssid, rsi_security_mode_t sec_type, void *secret_key, void(*scan_response_handler)(uint16_t status, const uint8_t *buffer, const uint16_t length));
+extern int32_t rsi_wlan_scan(const char *ssid, uint8_t chno,rsi_rsp_scan_t *result,uint32_t length);
+extern int32_t rsi_wlan_scan_async(const char *ssid, uint8_t chno, void(*callback)(uint16_t status, const uint8_t *buffer, const uint16_t length));
+extern int32_t rsi_wlan_connect(const char *ssid, rsi_security_mode_t sec_type, const char *secret_key);
+extern int32_t rsi_wlan_connect_async(const char *ssid, rsi_security_mode_t sec_type, const char *secret_key, void(*scan_response_handler)(uint16_t status, const uint8_t *buffer, const uint16_t length));
 extern int32_t rsi_wlan_ap_start(int8_t *ssid, uint8_t channel, rsi_security_mode_t security_type,rsi_encryption_mode_t encryption_mode, uint8_t *password, uint16_t beacon_interval, uint8_t dtim_period);
 extern int32_t rsi_wlan_execute_post_connect_cmds(void);
 extern int32_t rsi_wlan_disconnect(void);
@@ -1222,6 +1230,7 @@
 extern int32_t rsi_wlan_delete_profile(uint32_t type);
 extern int32_t rsi_wlan_enable_auto_config(uint8_t enable, uint32_t type);
 extern int32_t rsi_wlan_bgscan_profile(uint8_t cmd,rsi_rsp_scan_t *result,uint32_t length );
+extern int32_t rsi_wlan_bgscan_async(void(*callback)(uint16_t status, const uint8_t *buffer, const uint16_t length));
 
 extern int32_t rsi_wlan_power_save_profile(uint8_t psp_mode, uint8_t psp_type);
 
--- ./Wireless_Library/include/rsi_wlan_defines.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/include/rsi_wlan_defines.h	2019-04-17 14:51:12.434117277 +0100
@@ -21,8 +21,9 @@
 #ifndef RSI_WLAN_DEFINES_H
 #define RSI_WLAN_DEFINES_H
 
+#ifndef BIT
 #define BIT(a) ((long int)1 << a)
-
+#endif
 
 
 
--- ./Wireless_Library/include/rsi_wlan.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/include/rsi_wlan.h	2019-04-17 14:51:12.438117490 +0100
@@ -209,8 +209,9 @@
   RSI_WLAN_RSP_POP3_CLIENT            = 0xE7,
   RSI_WLAN_RSP_POP3_CLIENT_TERMINATE  = 0xE8,
   RSI_WLAN_RSP_DHCP_USER_CLASS        = 0xEC,
-  RSI_WLAN_RSP_TIMEOUT				  = 0xEA,
-  RSI_WLAN_RSP_URL_request		  	  =	0x64
+  RSI_WLAN_RSP_TIMEOUT                = 0xEA,
+  RSI_WLAN_RSP_URL_request            = 0x64,
+  RSI_WLAN_RSP_STATE_NOTIFICATION     = 0x70,
 
 }rsi_wlan_cmd_response_t;
 
@@ -364,8 +365,18 @@
   void   (*raw_data_receive_handler)(uint16_t status, uint8_t *buffer, const uint32_t length);
     void   (*auto_config_rsp_handler)(uint16_t status, uint8_t state);
 
+  //!wlan connection state notification handler
+  void   (*wlan_state_notification_handler)(uint16_t status, uint8_t *buffer, const uint32_t length);
+
 }rsi_callback_cb_t;
 
+typedef struct rsi_wlan_async_connect_ctx_s
+{
+  char ssid[RSI_SSID_LEN];
+  char secret_key[RSI_PSK_LEN];
+  rsi_security_mode_t sec_type;
+  void (*join_response_handler)(uint16_t status, const uint8_t *buffer, const uint16_t length);
+} rsi_wlan_async_connect_ctx_t;
 
 //! driver WLAN control block
 typedef struct rsi_wlan_cb_s
@@ -414,9 +425,10 @@
   
   //! opermode 
   uint16_t opermode;
-}rsi_wlan_cb_t;
-
 
+  //! Parameters saved during async connect while scanning.
+  rsi_wlan_async_connect_ctx_t *async_connect_ctx;
+}rsi_wlan_cb_t;
 
 //! Band command request structure
 typedef struct rsi_req_band_s 
@@ -1499,4 +1511,5 @@
 int32_t rsi_wlan_check_waiting_socket_cmd(void);
 int32_t rsi_wlan_check_waiting_wlan_cmd(void);
 void rsi_wlan_process_raw_data(rsi_pkt_t *pkt);
+void rsi_driver_wlan_free_async_connect_ctx(rsi_wlan_async_connect_ctx_t *ctx);
 #endif
--- ./Wireless_Library/os/free_rtos/rsi_os_wrapper.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/os/free_rtos/rsi_os_wrapper.c	2019-04-17 14:51:12.438117490 +0100
@@ -80,7 +80,7 @@
 {
 	//! restore interrupts while exiting critical section
   taskEXIT_CRITICAL();
-  
+  (void) xflags;
 }
 
 
@@ -136,7 +136,7 @@
 	{
 		timeout_ms = portMAX_DELAY;
 	}
-	if(xSemaphoreTake(*mutex, timeout_ms) == pdPASS)
+	if(xSemaphoreTake((QueueHandle_t) *mutex, timeout_ms) == pdPASS)
 	{
 		return RSI_ERROR_NONE;
 	}
@@ -219,10 +219,11 @@
 
 	*p_semaphore = xSemaphoreCreateBinary();
 
-	if(*semaphore == NULL)
+	if(*semaphore == 0)
 	{
 		return  RSI_ERROR_IN_OS_OPERATION;
 	}
+	(void) count;
 	return RSI_ERROR_NONE;
 
 }
@@ -275,7 +276,7 @@
 	{
 		timeout_ms = portMAX_DELAY;
 	}
-	if(xSemaphoreTake(*semaphore, timeout_ms) == pdPASS)
+	if(xSemaphoreTake((QueueHandle_t) *semaphore, timeout_ms) == pdPASS)
 	{
 		return RSI_ERROR_NONE;
 	}
@@ -394,7 +395,7 @@
 
 void rsi_task_destroy(rsi_task_handle_t *task_handle)
 {
-	vTaskDelete((TaskHandle_t *) task_handle);
+	vTaskDelete((TaskHandle_t) task_handle);
 }
 
 
--- ./Wireless_Library/rom/rsi_apis_non_rom.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/rom/rsi_apis_non_rom.c	2019-04-17 14:51:12.438117490 +0100
@@ -11,6 +11,7 @@
 #ifndef ROM_WIRELESS
 const struct ROM_WL_API_S api_wl_s={
  //! Socket APIs
+#if RSI_NUMBER_OF_SOCKETS > 0
   &ROM_WL_socket_async, 
   &ROM_WL_socket,  
   &ROM_WL_bind,  
@@ -29,6 +30,26 @@
   &ROM_WL_calculate_buffers_required,  
 	&ROM_WL_rsi_socket_create,
 	&ROM_WL_calculate_length_to_send,
+#else
+  NULL, // &ROM_WL_socket_async,
+  NULL, // &ROM_WL_socket,
+  NULL, // &ROM_WL_bind,
+  NULL, // &ROM_WL_connect,
+  NULL, // &ROM_WL_listen,
+  NULL, // &ROM_WL_accept,
+  NULL, // &ROM_WL_recvfrom,
+  NULL, // &ROM_WL_recv,
+  NULL, // &ROM_WL_sendto,
+  NULL, // &ROM_WL_sendto_async,
+  NULL, // &ROM_WL_send,
+  NULL, // &ROM_WL_send_async,
+  NULL, // &ROM_WL_shutdown,
+  NULL, // &ROM_WL_rsi_get_application_socket_descriptor,
+  NULL, // &ROM_WL_rsi_clear_sockets,
+  NULL, // &ROM_WL_calculate_buffers_required,
+  NULL, // &ROM_WL_rsi_socket_create,
+  NULL, // &ROM_WL_calculate_length_to_send,
+#endif
 
   //! Scheduler
   &ROM_WL_rsi_scheduler_init,  
@@ -50,7 +71,11 @@
   &ROM_WL_rsi_unblock_queue,  
 
 
+#if RSI_NUMBER_OF_SOCKETS > 0
   &ROM_WL_rsi_driver_send_data,  
+#else
+  NULL,
+#endif
   &ROM_WL_rsi_driver_process_recv_data, 
 
   //! Events
@@ -92,7 +117,9 @@
   global_cb_p             = &global_cb;
 
   global_cb_p->rsi_driver_cb   = rsi_driver_cb;
+#if RSI_NUMBER_OF_SOCKETS > 0
   global_cb_p->rsi_socket_pool = rsi_socket_pool;
+#endif
   global_cb_p->rom_apis_p      = &rom_apis;
   global_cb_p->no_of_sockets   = RSI_NUMBER_OF_SOCKETS;
 #ifdef RSI_LITTLE_ENDIAN
--- ./Wireless_Library/rom/rsi_apis_rom.h.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/rom/rsi_apis_rom.h	2019-04-17 14:51:12.438117490 +0100
@@ -133,7 +133,7 @@
 #endif
 
 
-const typedef struct ROM_WL_API_S{
+typedef const struct ROM_WL_API_S{
 
   //! Socket APIs
   int32_t    (*socket_async)(global_cb_t *global_cb_p, int32_t protocolFamily, int32_t type, int32_t protocol, void (*callback)(uint32_t sock_no, uint8_t *buffer, uint32_t length));
@@ -206,8 +206,9 @@
 
 
 
-
+#ifndef ROMAPI_WL
 #define ROMAPI_WL ((ROM_WL_API_T *)(*(uint32_t *)(0x300100 + (20*4))))
+#endif
 
 
 extern ROM_WL_API_T *api_wl;
--- ./Wireless_Library/rom/rsi_hal_mcu_m4_rom.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/rom/rsi_hal_mcu_m4_rom.c	2019-04-17 14:51:12.438117490 +0100
@@ -118,7 +118,7 @@
 	 
     //!raise interrupt to TA 
     ROM_WL_rsi_raise_pkt_pending_interrupt_to_ta();
-	   
+	  (void) tx_desc;
 	  //! return success
 	  return 0;
 
@@ -180,7 +180,7 @@
 
   }
 
-  return  ((rsi_pkt_t *)((rx_desc[0].addr - M4_MEMORY_OFFSET_ADDRESS) - 4));
+  return  ((rsi_pkt_t *)((rx_desc[0].addr | M4_MEMORY_OFFSET_ADDRESS) - 4));
   
 
 }
@@ -262,13 +262,13 @@
   pkt_buffer = (int8_t *)&rx_pkt->desc[0];
   
   //! Fill source address in the TX descriptors
-  rx_desc[0].addr = (M4_MEMORY_OFFSET_ADDRESS + (uint32_t)pkt_buffer);
+  rx_desc[0].addr = (M4_MEMORY_OFFSET_ADDRESS | (uint32_t)pkt_buffer);
 
   //! Fill source address in the TX descriptors
   rx_desc[0].length = (16);
 
   //! Fill source address in the TX descriptors
-  rx_desc[1].addr = (M4_MEMORY_OFFSET_ADDRESS + (uint32_t)(pkt_buffer+16));
+  rx_desc[1].addr = (M4_MEMORY_OFFSET_ADDRESS | (uint32_t)(pkt_buffer+16));
 
   //! Fill source address in the TX descriptors
   rx_desc[1].length = (1600);
@@ -330,13 +330,13 @@
    }
 
 	//! Fill source address in the TX descriptors
-	tx_desc[0].addr = (M4_MEMORY_OFFSET_ADDRESS + (uint32_t)uFrameDscFrame);
+	tx_desc[0].addr = (M4_MEMORY_OFFSET_ADDRESS | (uint32_t)uFrameDscFrame);
 	
 	//! Fill source address in the TX descriptors
 	tx_desc[0].length = (16);
 
 	//! Fill source address in the TX descriptors
-	tx_desc[1].addr = (M4_MEMORY_OFFSET_ADDRESS + (uint32_t)payloadparam);
+	tx_desc[1].addr = (M4_MEMORY_OFFSET_ADDRESS | (uint32_t)payloadparam);
 
 		//! Fill source address in the TX descriptors
 	tx_desc[1].length = (size_param);
--- ./Wireless_Library/rom/rsi_nwk_rom.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/rom/rsi_nwk_rom.c	2019-04-17 14:51:12.438117490 +0100
@@ -43,6 +43,7 @@
  *
  */
 
+#if RSI_NUMBER_OF_SOCKETS > 0
 int32_t ROM_WL_rsi_driver_send_data(global_cb_t *global_cb_p, uint32_t sockID, uint8_t* buffer, uint32_t length, struct rsi_sockaddr *destAddr)
 {
   int32_t  status = RSI_SUCCESS;
@@ -176,7 +177,7 @@
   return status;
 
 }
-
+#endif // RSI_NUMBER_OF_SOCKETS > 0
 
 /*==============================================*/
 /**
@@ -207,7 +208,9 @@
   int32_t status = RSI_SUCCESS;
   
   rsi_driver_cb_t   *rsi_driver_cb   = global_cb_p->rsi_driver_cb;
+#if RSI_NUMBER_OF_SOCKETS > 0
   rsi_socket_info_t *rsi_socket_pool = global_cb_p->rsi_socket_pool;
+#endif
 
   //! Get payload pointer
   recv = (rsi_rsp_socket_recv_t *)pkt->data;
@@ -233,6 +236,7 @@
   }
   else
   {
+#if RSI_NUMBER_OF_SOCKETS > 0
   //! Get socket descriptor
   sockID = ROM_WL_rsi_get_application_socket_descriptor(global_cb_p, recv->socket_id[0]);
 
@@ -318,6 +322,15 @@
       memcpy(sock_info->destination_ip_addr.ipv6, recv->dest_ip_addr.ipv6_address, RSI_IPV6_ADDRESS_LENGTH);
     }
   }
+#else
+  (void) sockID;
+  (void) rsi_socket_pool;
+  (void) recv;
+  (void) sock_info;
+  (void) websocket_info;
+  (void) data_length;
+  (void) data_offset;
+#endif
 
   //! Post semaphore for data read request
   if(rsi_driver_cb->wlan_cb->expected_response  == RSI_WLAN_RSP_SOCKET_READ_DATA)
--- ./Wireless_Library/rom/rsi_pkt_mgmt_rom.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/rom/rsi_pkt_mgmt_rom.c	2019-04-17 14:51:12.438117490 +0100
@@ -96,6 +96,8 @@
     total_size -= pkt_size;
   }
 
+  (void) global_cb_p;
+
   //! Return success
   return 0;
 }
@@ -146,6 +148,8 @@
   //! Retore interrupts
   RSI_CRITICAL_SECTION_EXIT(flags);
 
+  (void) global_cb_p;
+
   //! Return pakcet pointer 
   return pkt;
 }
@@ -193,6 +197,8 @@
   //! Retore interrupts
   RSI_CRITICAL_SECTION_EXIT(flags);
 
+  (void) global_cb_p;
+
   return RSI_SUCCESS;
 }
 
@@ -226,6 +232,8 @@
   //! Retore interrupts
   RSI_CRITICAL_SECTION_EXIT(flags);
 
+  (void) global_cb_p;
+
   //! Return available count
   return available_count;
 
--- ./Wireless_Library/rom/rsi_queue_rom.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/rom/rsi_queue_rom.c	2019-04-17 14:51:12.438117490 +0100
@@ -56,6 +56,7 @@
   //! Mutex for  queues 
   RSI_MUTEX_CREATE(&queue->queue_mutex);
 
+  (void) global_cb_p;
 }
 /*==============================================*/
 /**
@@ -99,6 +100,7 @@
   //! Unlock the queue
   RSI_MUTEX_UNLOCK(&queue->queue_mutex);
 
+  (void) global_cb_p;
 }
 /*==============================================*/
 /**
@@ -150,6 +152,8 @@
   //! Unlock the mutex
   RSI_MUTEX_UNLOCK(&queue->queue_mutex);
 
+  (void) global_cb_p;
+
   //! return the packet
   return pkt;
 }
@@ -197,6 +201,8 @@
     //! if queue is not masked return number of packets pending
     return pkt_count;
   }
+
+  (void) global_cb_p;
 }
 
 /*====================================================*/
@@ -220,6 +226,7 @@
   //! Unlock the mutex
   RSI_MUTEX_UNLOCK(&queue->queue_mutex);
 
+  (void) global_cb_p;
 }
 
 /*====================================================*/
@@ -244,5 +251,6 @@
   //! Unlock the mutex
   RSI_MUTEX_UNLOCK(&queue->queue_mutex);
 
+  (void) global_cb_p;
 }
 #endif
--- ./Wireless_Library/rom/rsi_scheduler_rom.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/rom/rsi_scheduler_rom.c	2019-04-17 14:51:12.438117490 +0100
@@ -70,7 +70,9 @@
   
   //! Enable all the interrupts
   RSI_CRITICAL_SECTION_EXIT(flags);
-  
+
+  (void) global_cb_p;
+
   return active_int_event_map;
   
 }
@@ -119,7 +121,7 @@
   
   if(global_cb_p->os_enabled == 1)
   {
-    RSI_SEMAPHORE_WAIT(&scheduler_cb->scheduler_sem, 0);
+    RSI_SEMAPHORE_WAIT(&scheduler_cb->scheduler_sem, 1);
   }
 }
 #endif
--- ./Wireless_Library/wlan/rsi_wlan_apis.c.orig	2018-10-24 19:33:26.000000000 +0100
+++ ./Wireless_Library/wlan/rsi_wlan_apis.c	2019-04-17 19:04:08.164533439 +0100
@@ -37,7 +37,7 @@
  * application. Application should call this api to get the scan results.
  *
  */
-int32_t rsi_wlan_scan(int8_t *ssid, uint8_t chno, rsi_rsp_scan_t *result,uint32_t length)
+int32_t rsi_wlan_scan(const char *ssid, uint8_t chno, rsi_rsp_scan_t *result,uint32_t length)
 {
   int8_t          status = RSI_SUCCESS;
 
@@ -93,7 +93,7 @@
  *
  */
 
-int32_t rsi_wlan_scan_async(int8_t *ssid, uint8_t chno, void (*scan_response_handler)(uint16_t status, const uint8_t *buffer, const uint16_t length))
+int32_t rsi_wlan_scan_async(const char *ssid, uint8_t chno, void (*scan_response_handler)(uint16_t status, const uint8_t *buffer, const uint16_t length))
 
 {
   rsi_pkt_t       *pkt;
@@ -108,6 +108,16 @@
   {
     //! take lock on wlan control block
     rsi_mutex_lock(&wlan_cb->wlan_mutex);
+
+    //! check if another scan is already in progress
+    if(wlan_cb->callback_list.wlan_scan_response_handler != NULL)
+    {
+      //! unlock mutex
+      rsi_mutex_unlock(&wlan_cb->wlan_mutex);
+
+      //! Command given in wrong state 
+      return RSI_ERROR_COMMAND_GIVEN_IN_WRONG_STATE;
+    }
   }
 
   //! allocate command buffer  from wlan pool
@@ -180,6 +190,7 @@
           return status;
         }
       }
+      // fall through
     case RSI_WLAN_STATE_BAND_DONE:
       {
 #if RSI_TIMEOUT_SUPPORT
@@ -247,6 +258,7 @@
 
 
       }
+      // fall through
     case RSI_WLAN_STATE_SCAN_DONE:
     case RSI_WLAN_STATE_INIT_DONE:
     case RSI_WLAN_STATE_CONNECTED:
@@ -315,7 +327,7 @@
  *
  */
 
-int32_t rsi_wlan_connect(int8_t *ssid, rsi_security_mode_t sec_type, void *secret_key)
+int32_t rsi_wlan_connect(const char *ssid, rsi_security_mode_t sec_type, const char *secret_key)
 {
 
   int8_t          status = RSI_SUCCESS;
@@ -373,7 +385,8 @@
  *
  */
 
-int32_t rsi_wlan_connect_async(int8_t *ssid, rsi_security_mode_t sec_type, void *secret_key, void (*join_response_handler)(uint16_t status, const uint8_t *buffer, const uint16_t length))
+int32_t rsi_wlan_connect_async(const char *ssid, rsi_security_mode_t sec_type, const char *secret_key,
+                               void (*join_response_handler)(uint16_t status, const uint8_t *buffer, const uint16_t length))
 {
   rsi_eap_credentials_t *credentials;
   rsi_req_wps_method_t *wps_method;
@@ -477,6 +490,7 @@
           return status;
         }
       }
+      // fall through
     case RSI_WLAN_STATE_BAND_DONE:
       {
 
@@ -546,6 +560,7 @@
 
       
       }
+      // fall through
     case RSI_WLAN_STATE_INIT_DONE:
       {
 #if RSI_WMM_PS_ENABLE 
@@ -625,6 +640,37 @@
           rsi_strcpy(scan->ssid, ssid);
         }
 
+        if(join_response_handler != NULL )
+        {
+          rsi_wlan_async_connect_ctx_t *ctx = (rsi_wlan_async_connect_ctx_t *) calloc(1, sizeof(*ctx));
+
+          if(ctx == NULL)
+          {
+            rsi_pkt_free(&wlan_cb->wlan_tx_pool, pkt);
+
+            return RSI_ERROR_INSUFFICIENT_BUFFER;
+          }
+
+          ctx->sec_type = sec_type;
+
+          if(ssid != NULL)
+          {
+            strncpy(ctx->ssid, ssid, sizeof(ctx->ssid) - 1);
+          }
+
+          if(secret_key != NULL)
+          {
+            strncpy(ctx->secret_key, secret_key, sizeof(ctx->secret_key) - 1);
+          }
+
+          ctx->join_response_handler = join_response_handler;
+
+          //! Magic number to set asyncronous response
+          wlan_cb->expected_response = RSI_WLAN_RSP_ASYNCHRONOUS ;
+
+          wlan_cb->async_connect_ctx = ctx;
+        }
+
         //! send scan command 
         status = rsi_driver_wlan_send_cmd(RSI_WLAN_REQ_SCAN, pkt);
 
@@ -633,6 +679,13 @@
           //! free the packet
           rsi_pkt_free(&wlan_cb->wlan_tx_pool, pkt);
 
+          if(wlan_cb->async_connect_ctx != NULL)
+          {
+            rsi_wlan_async_connect_ctx_t *ctx = wlan_cb->async_connect_ctx;
+            wlan_cb->async_connect_ctx = NULL;
+            rsi_driver_wlan_free_async_connect_ctx(ctx);
+          }
+
           if(join_response_handler != NULL)
           {
             //! unlock mutex
@@ -642,7 +695,13 @@
           //! Return the status if error in sending command occurs
           return status;
         }
+        if(join_response_handler != NULL)
+        {
+          // Scan will take place and we'll re-enter this function.
+          break;
+        }
       }
+      // fall through
     case RSI_WLAN_STATE_SCAN_DONE:
       {
 #if RSI_WMM_PS_ENABLE 
@@ -835,12 +894,12 @@
           rsi_strcpy(join->ssid, ssid);
         }
 
-        //! Magic number to set asyncronous reswponse
+        //! Magic number to set asyncronous response
         wlan_cb->expected_response = RSI_WLAN_RSP_ASYNCHRONOUS ;
 
         if(join_response_handler != NULL )
         {
-          //! Register scan response handler
+          //! Register join response handler
           wlan_cb->callback_list.wlan_join_response_handler = join_response_handler;
         }
 
@@ -953,6 +1012,76 @@
   //! Return the status if error in sending command occurs
   return status;
 }
+
+int32_t rsi_wlan_bgscan_async(void(*scan_response_handler)(uint16_t status, const uint8_t *buffer, const uint16_t length))
+{
+  rsi_pkt_t       *pkt; 
+  int8_t      status = RSI_SUCCESS;
+
+  //! Get wlan cb structure pointer
+  rsi_wlan_cb_t *wlan_cb = rsi_driver_cb->wlan_cb;
+
+  //! check whether module is in valid state range or not
+  if(wlan_cb->state < RSI_WLAN_STATE_CONNECTED)
+  {
+    //! Command given in wrong state 
+    return RSI_ERROR_COMMAND_GIVEN_IN_WRONG_STATE;
+  }
+
+  //! take lock on wlan control block
+  rsi_mutex_lock(&wlan_cb->wlan_mutex);
+
+  //! check if another scan is already in progress
+  if(wlan_cb->callback_list.wlan_scan_response_handler != NULL)
+  {
+    //! unlock mutex
+    rsi_mutex_unlock(&wlan_cb->wlan_mutex);
+
+    //! Command given in wrong state 
+    return RSI_ERROR_COMMAND_GIVEN_IN_WRONG_STATE;
+  }
+
+  //! allocate command buffer  from wlan pool
+  pkt = rsi_pkt_alloc(&wlan_cb->wlan_tx_pool);
+
+  //! If allocation of packet fails
+  if(pkt == NULL)
+  {
+    //! unlock mutex
+    rsi_mutex_unlock(&wlan_cb->wlan_mutex);
+
+    //! return packet allocation failure error
+    return RSI_ERROR_PKT_ALLOCATION_FAILURE;
+  }
+
+  //! Memset data
+  memset(&pkt->data,0,sizeof(rsi_req_bg_scan_t));
+
+  //! Magic word
+  pkt->data[0] = 0xAB;
+  
+  //! cmd
+  pkt->data[1] = 1;
+
+  // Response will be async
+  wlan_cb->app_buffer = NULL;
+  wlan_cb->app_buffer_length = 0;
+  wlan_cb->expected_response = RSI_WLAN_RSP_ASYNCHRONOUS ;
+  wlan_cb->callback_list.wlan_scan_response_handler = scan_response_handler;
+
+  //! send bg scan command 
+  status = rsi_driver_wlan_send_cmd(RSI_WLAN_REQ_BG_SCAN, pkt);
+
+  //! free the packet
+  rsi_pkt_free(&wlan_cb->wlan_tx_pool, pkt);
+
+  //! unlock mutex
+  rsi_mutex_unlock(&wlan_cb->wlan_mutex);
+
+  //! Return the status if error in sending command occurs
+  return status;
+}
+
 /*==============================================*/
 /**
  * @fn        int32_t rsi_wlan_execute_post_connect_cmds(void)
@@ -2093,6 +2222,8 @@
   //! unlock mutex
   rsi_mutex_unlock(&wlan_cb->wlan_mutex);
 
+  (void) length;
+
   //! Return the status
   return status;
 
@@ -2266,6 +2397,7 @@
           return status;
         }
       }
+      // fall through
     case RSI_WLAN_STATE_BAND_DONE:
       {
         //! send init command 
@@ -2304,6 +2436,7 @@
 #endif       
 
       }
+      // fall through
     case RSI_WLAN_STATE_IP_CONFIG_DONE:
     case RSI_WLAN_STATE_IPV6_CONFIG_DONE:
     case RSI_WLAN_STATE_INIT_DONE:
@@ -3984,10 +4117,10 @@
   psk_ptr->type = type;
 
   //! copy PSK given by user into structure member
-  strcpy(psk_ptr->psk_or_pmk,psk);
+  strcpy((char *) psk_ptr->psk_or_pmk, (const char *) psk);
 
   //! copy SSID given by user into structure member
-  strcpy(psk_ptr->ap_ssid,ssid);
+  strcpy((char *) psk_ptr->ap_ssid, (const char *) ssid);
 
   //! send psk command 
   status = rsi_driver_wlan_send_cmd(RSI_WLAN_REQ_HOST_PSK, pkt);
@@ -4018,7 +4151,7 @@
  */
 uint16_t rsi_wlan_register_callbacks(uint32_t callback_id, void (*callback_handler_ptr)(uint16_t status, uint8_t *buffer, const uint32_t length))
 {
-  if(callback_id > RSI_MAX_NUM_CALLBACKS)
+  if(callback_id >= RSI_WLAN_MAX_NUM_CALLBACKS)
   {
     /*
      *Return , if the callback number exceeds the RSI_MAX_NUM_CALLBACKS ,or
@@ -4080,7 +4213,11 @@
   {
     //! Register raw data receive notify call back handler
     rsi_driver_cb->wlan_cb->callback_list.raw_data_receive_handler = callback_handler_ptr;
-    
+  }
+  else if(callback_id == RSI_WLAN_STATE_NOTIFICATION_HANDLER)
+  {
+    //! Register async connection status notification handler
+    rsi_driver_cb->wlan_cb->callback_list.wlan_state_notification_handler = callback_handler_ptr;
   }
   return 0;
 }
